"use strict";
(self["webpackChunkeditor"] = self["webpackChunkeditor"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_basic-languages_elixir_elixir_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conf": () => (/* binding */ conf),
/* harmony export */   "language": () => (/* binding */ language)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var conf = {
    comments: {
        lineComment: '#'
    },
    brackets: [
        ['{', '}'],
        ['[', ']'],
        ['(', ')']
    ],
    surroundingPairs: [
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '(', close: ')' },
        { open: "'", close: "'" },
        { open: '"', close: '"' }
    ],
    autoClosingPairs: [
        { open: "'", close: "'", notIn: ['string', 'comment'] },
        { open: '"', close: '"', notIn: ['comment'] },
        { open: '"""', close: '"""' },
        { open: '`', close: '`', notIn: ['string', 'comment'] },
        { open: '(', close: ')' },
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '<<', close: '>>' }
    ],
    indentationRules: {
        increaseIndentPattern: /^\s*(after|else|catch|rescue|fn|[^#]*(do|<\-|\->|\{|\[|\=))\s*$/,
        decreaseIndentPattern: /^\s*((\}|\])\s*$|(after|else|catch|rescue|end)\b)/
    }
};
/**
 * A Monarch lexer for the Elixir language.
 *
 * References:
 *
 * * Monarch documentation - https://microsoft.github.io/monaco-editor/monarch.html
 * * Elixir lexer - https://github.com/elixir-makeup/makeup_elixir/blob/master/lib/makeup/lexers/elixir_lexer.ex
 * * TextMate lexer (elixir-tmbundle) - https://github.com/elixir-editors/elixir-tmbundle/blob/master/Syntaxes/Elixir.tmLanguage
 * * TextMate lexer (vscode-elixir-ls) - https://github.com/elixir-lsp/vscode-elixir-ls/blob/master/syntaxes/elixir.json
 */
var language = {
    defaultToken: 'source',
    tokenPostfix: '.elixir',
    brackets: [
        { open: '[', close: ']', token: 'delimiter.square' },
        { open: '(', close: ')', token: 'delimiter.parenthesis' },
        { open: '{', close: '}', token: 'delimiter.curly' },
        { open: '<<', close: '>>', token: 'delimiter.angle.special' }
    ],
    // Below are lists/regexps to which we reference later.
    declarationKeywords: [
        'def',
        'defp',
        'defn',
        'defnp',
        'defguard',
        'defguardp',
        'defmacro',
        'defmacrop',
        'defdelegate',
        'defcallback',
        'defmacrocallback',
        'defmodule',
        'defprotocol',
        'defexception',
        'defimpl',
        'defstruct'
    ],
    operatorKeywords: ['and', 'in', 'not', 'or', 'when'],
    namespaceKeywords: ['alias', 'import', 'require', 'use'],
    otherKeywords: [
        'after',
        'case',
        'catch',
        'cond',
        'do',
        'else',
        'end',
        'fn',
        'for',
        'if',
        'quote',
        'raise',
        'receive',
        'rescue',
        'super',
        'throw',
        'try',
        'unless',
        'unquote_splicing',
        'unquote',
        'with'
    ],
    constants: ['true', 'false', 'nil'],
    nameBuiltin: ['__MODULE__', '__DIR__', '__ENV__', '__CALLER__', '__STACKTRACE__'],
    // Matches any of the operator names:
    // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !
    operator: /-[->]?|!={0,2}|\*|\/|\\\\|&{1,3}|\.\.?|\^(?:\^\^)?|\+\+?|<(?:-|<<|=|>|\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\|~>|\|>|\|{1,3}|~>>?|~~~|::/,
    // See https://hexdocs.pm/elixir/syntax-reference.html#variables
    variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,
    // See https://hexdocs.pm/elixir/syntax-reference.html#atoms
    atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,
    specialAtomName: /\.\.\.|<<>>|%\{\}|%|\{\}/,
    aliasPart: /[A-Z][a-zA-Z0-9_]*/,
    moduleName: /@aliasPart(?:\.@aliasPart)*/,
    // Sigil pairs are: """ """, ''' ''', " ", ' ', / /, | |, < >, { }, [ ], ( )
    sigilSymmetricDelimiter: /"""|'''|"|'|\/|\|/,
    sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\{|\[|\(/,
    sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\}|\]|\)/,
    decimal: /\d(?:_?\d)*/,
    hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,
    octal: /[0-7](_?[0-7])*/,
    binary: /[01](_?[01])*/,
    // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters
    escape: /\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}|\\./,
    // The keys below correspond to tokenizer states.
    // We start from the root state and match against its rules
    // until we explicitly transition into another state.
    // The `include` simply brings in all operations from the given state
    // and is useful for improving readability.
    tokenizer: {
        root: [
            { include: '@whitespace' },
            { include: '@comments' },
            // Keywords start as either an identifier or a string,
            // but end with a : so it's important to match this first.
            { include: '@keywordsShorthand' },
            { include: '@numbers' },
            { include: '@identifiers' },
            { include: '@strings' },
            { include: '@atoms' },
            { include: '@sigils' },
            { include: '@attributes' },
            { include: '@symbols' }
        ],
        // Whitespace
        whitespace: [[/\s+/, 'white']],
        // Comments
        comments: [[/(#)(.*)/, ['comment.punctuation', 'comment']]],
        // Keyword list shorthand
        keywordsShorthand: [
            [/(@atomName)(:)/, ['constant', 'constant.punctuation']],
            // Use positive look-ahead to ensure the string is followed by :
            // and should be considered a keyword.
            [
                /"(?=([^"]|#\{.*?\}|\\")*":)/,
                { token: 'constant.delimiter', next: '@doubleQuotedStringKeyword' }
            ],
            [
                /'(?=([^']|#\{.*?\}|\\')*':)/,
                { token: 'constant.delimiter', next: '@singleQuotedStringKeyword' }
            ]
        ],
        doubleQuotedStringKeyword: [
            [/":/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        singleQuotedStringKeyword: [
            [/':/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        // Numbers
        numbers: [
            [/0b@binary/, 'number.binary'],
            [/0o@octal/, 'number.octal'],
            [/0x@hex/, 'number.hex'],
            [/@decimal\.@decimal([eE]-?@decimal)?/, 'number.float'],
            [/@decimal/, 'number']
        ],
        // Identifiers
        identifiers: [
            // Tokenize identifier name in function-like definitions.
            // Note: given `def a + b, do: nil`, `a` is not a function name,
            // so we use negative look-ahead to ensure there's no operator.
            [
                /\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\s+)(@variableName)(?!\s+@operator)/,
                [
                    'keyword.declaration',
                    'white',
                    {
                        cases: {
                            unquote: 'keyword',
                            '@default': 'function'
                        }
                    }
                ]
            ],
            // Tokenize function calls
            [
                // In-scope call - an identifier followed by ( or .(
                /(@variableName)(?=\s*\.?\s*\()/,
                {
                    cases: {
                        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`
                        '@declarationKeywords': 'keyword.declaration',
                        '@namespaceKeywords': 'keyword',
                        '@otherKeywords': 'keyword',
                        '@default': 'function.call'
                    }
                }
            ],
            [
                // Referencing function in a module
                /(@moduleName)(\s*)(\.)(\s*)(@variableName)/,
                ['type.identifier', 'white', 'operator', 'white', 'function.call']
            ],
            [
                // Referencing function in an Erlang module
                /(:)(@atomName)(\s*)(\.)(\s*)(@variableName)/,
                ['constant.punctuation', 'constant', 'white', 'operator', 'white', 'function.call']
            ],
            [
                // Piping into a function (tokenized separately as it may not have parentheses)
                /(\|>)(\s*)(@variableName)/,
                [
                    'operator',
                    'white',
                    {
                        cases: {
                            '@otherKeywords': 'keyword',
                            '@default': 'function.call'
                        }
                    }
                ]
            ],
            [
                // Function reference passed to another function
                /(&)(\s*)(@variableName)/,
                ['operator', 'white', 'function.call']
            ],
            // Language keywords, builtins, constants and variables
            [
                /@variableName/,
                {
                    cases: {
                        '@declarationKeywords': 'keyword.declaration',
                        '@operatorKeywords': 'keyword.operator',
                        '@namespaceKeywords': 'keyword',
                        '@otherKeywords': 'keyword',
                        '@constants': 'constant.language',
                        '@nameBuiltin': 'variable.language',
                        '_.*': 'comment.unused',
                        '@default': 'identifier'
                    }
                }
            ],
            // Module names
            [/@moduleName/, 'type.identifier']
        ],
        // Strings
        strings: [
            [/"""/, { token: 'string.delimiter', next: '@doubleQuotedHeredoc' }],
            [/'''/, { token: 'string.delimiter', next: '@singleQuotedHeredoc' }],
            [/"/, { token: 'string.delimiter', next: '@doubleQuotedString' }],
            [/'/, { token: 'string.delimiter', next: '@singleQuotedString' }]
        ],
        doubleQuotedHeredoc: [
            [/"""/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        singleQuotedHeredoc: [
            [/'''/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        doubleQuotedString: [
            [/"/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        singleQuotedString: [
            [/'/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        // Atoms
        atoms: [
            [/(:)(@atomName)/, ['constant.punctuation', 'constant']],
            [/:"/, { token: 'constant.delimiter', next: '@doubleQuotedStringAtom' }],
            [/:'/, { token: 'constant.delimiter', next: '@singleQuotedStringAtom' }]
        ],
        doubleQuotedStringAtom: [
            [/"/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        singleQuotedStringAtom: [
            [/'/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        // Sigils
        // See https://elixir-lang.org/getting-started/sigils.html
        // Sigils allow for typing values using their textual representation.
        // All sigils start with ~ followed by a letter indicating sigil type
        // and then a delimiter pair enclosing the textual representation.
        // Optional modifiers are allowed after the closing delimiter.
        // For instance a regular expressions can be written as:
        // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g
        //
        // In general lowercase sigils allow for interpolation
        // and escaped characters, whereas uppercase sigils don't
        //
        // During tokenization we want to distinguish some
        // specific sigil types, namely string and regexp,
        // so that they cen be themed separately.
        //
        // To reasonably handle all those combinations we leverage
        // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}
        // then "sigilStart.interpol.s" state will match and also all
        // the individual dot-separated parameters can be accessed.
        sigils: [
            [/~[a-z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.interpol' }],
            [/~[A-Z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.noInterpol' }]
        ],
        sigil: [
            [/~([a-zA-Z])\{/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.{.}' }],
            [/~([a-zA-Z])\[/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.[.]' }],
            [/~([a-zA-Z])\(/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.(.)' }],
            [/~([a-zA-Z])\</, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.<.>' }],
            [
                /~([a-zA-Z])(@sigilSymmetricDelimiter)/,
                { token: '@rematch', switchTo: '@sigilStart.$S2.$1.$2.$2' }
            ]
        ],
        // The definitions below expect states to be of the form:
        //
        // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>
        // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>
        //
        // The sigilStart state is used only to properly classify the token (as string/regex/sigil)
        // and immediately switches to the sigilContinue sate, which handles the actual content
        // and waits for the corresponding end delimiter.
        'sigilStart.interpol.s': [
            [
                /~s@sigilStartDelimiter/,
                {
                    token: 'string.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.interpol.s': [
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },
                        '@default': 'string'
                    }
                }
            ],
            { include: '@stringContentInterpol' }
        ],
        'sigilStart.noInterpol.S': [
            [
                /~S@sigilStartDelimiter/,
                {
                    token: 'string.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.noInterpol.S': [
            // Ignore escaped sigil end
            [/(^|[^\\])\\@sigilEndDelimiter/, 'string'],
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },
                        '@default': 'string'
                    }
                }
            ],
            { include: '@stringContent' }
        ],
        'sigilStart.interpol.r': [
            [
                /~r@sigilStartDelimiter/,
                {
                    token: 'regexp.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.interpol.r': [
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },
                        '@default': 'regexp'
                    }
                }
            ],
            { include: '@regexpContentInterpol' }
        ],
        'sigilStart.noInterpol.R': [
            [
                /~R@sigilStartDelimiter/,
                {
                    token: 'regexp.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.noInterpol.R': [
            // Ignore escaped sigil end
            [/(^|[^\\])\\@sigilEndDelimiter/, 'regexp'],
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },
                        '@default': 'regexp'
                    }
                }
            ],
            { include: '@regexpContent' }
        ],
        // Fallback to the generic sigil by default
        'sigilStart.interpol': [
            [
                /~([a-zA-Z])@sigilStartDelimiter/,
                {
                    token: 'sigil.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.interpol': [
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },
                        '@default': 'sigil'
                    }
                }
            ],
            { include: '@sigilContentInterpol' }
        ],
        'sigilStart.noInterpol': [
            [
                /~([a-zA-Z])@sigilStartDelimiter/,
                {
                    token: 'sigil.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.noInterpol': [
            // Ignore escaped sigil end
            [/(^|[^\\])\\@sigilEndDelimiter/, 'sigil'],
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },
                        '@default': 'sigil'
                    }
                }
            ],
            { include: '@sigilContent' }
        ],
        // Attributes
        attributes: [
            // Module @doc* attributes - tokenized as comments
            [
                /\@(module|type)?doc (~[sS])?"""/,
                {
                    token: 'comment.block.documentation',
                    next: '@doubleQuotedHeredocDocstring'
                }
            ],
            [
                /\@(module|type)?doc (~[sS])?"/,
                {
                    token: 'comment.block.documentation',
                    next: '@doubleQuotedStringDocstring'
                }
            ],
            [/\@(module|type)?doc false/, 'comment.block.documentation'],
            // Module attributes
            [/\@(@variableName)/, 'variable']
        ],
        doubleQuotedHeredocDocstring: [
            [/"""/, { token: 'comment.block.documentation', next: '@pop' }],
            { include: '@docstringContent' }
        ],
        doubleQuotedStringDocstring: [
            [/"/, { token: 'comment.block.documentation', next: '@pop' }],
            { include: '@docstringContent' }
        ],
        // Operators, punctuation, brackets
        symbols: [
            // Code point operator (either with regular character ?a or an escaped one ?\n)
            [/\?(\\.|[^\\\s])/, 'number.constant'],
            // Anonymous function arguments
            [/&\d+/, 'operator'],
            // Bitshift operators (must go before delimiters, so that << >> don't match first)
            [/<<<|>>>/, 'operator'],
            // Delimiter pairs
            [/[()\[\]\{\}]|<<|>>/, '@brackets'],
            // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)
            [/\.\.\./, 'identifier'],
            // Punctuation => (must go before operators, so it's not tokenized as = then >)
            [/=>/, 'punctuation'],
            // Operators
            [/@operator/, 'operator'],
            // Punctuation
            [/[:;,.%]/, 'punctuation']
        ],
        // Generic helpers
        stringContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@stringContent' }
        ],
        stringContent: [[/./, 'string']],
        stringConstantContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@stringConstantContent' }
        ],
        stringConstantContent: [[/./, 'constant']],
        regexpContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@regexpContent' }
        ],
        regexpContent: [
            // # may be a regular regexp char, so we use a heuristic
            // assuming a # surrounded by whitespace is actually a comment.
            [/(\s)(#)(\s.*)$/, ['white', 'comment.punctuation', 'comment']],
            [/./, 'regexp']
        ],
        sigilContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@sigilContent' }
        ],
        sigilContent: [[/./, 'sigil']],
        docstringContent: [[/./, 'comment.block.documentation']],
        escapeChar: [[/@escape/, 'constant.character.escape']],
        interpolation: [
            [/#{/, { token: 'delimiter.bracket.embed', next: '@interpolationContinue' }]
        ],
        interpolationContinue: [
            [/}/, { token: 'delimiter.bracket.embed', next: '@pop' }],
            // Interpolation brackets may contain arbitrary code,
            // so we simply match against all the root rules,
            // until we reach interpolation end (the above matches).
            { include: '@root' }
        ]
    }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzaWMtbGFuZ3VhZ2VzX2VsaXhpcl9lbGl4aXJfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVEsWUFBWSxHQUFHO0FBQ2pDLFVBQVUsdUJBQXVCO0FBQ2pDLFVBQVUsdUJBQXVCO0FBQ2pDLFVBQVUsdUJBQXVCO0FBQ2pDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSwyQ0FBMkM7QUFDckQsVUFBVSwyQkFBMkI7QUFDckMsVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSxRQUFRLFlBQVksR0FBRztBQUNqQyxVQUFVLHVCQUF1QjtBQUNqQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtEQUFrRDtBQUM1RCxVQUFVLHVEQUF1RDtBQUNqRSxVQUFVLFFBQVEsWUFBWSw2QkFBNkI7QUFDM0QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksY0FBYyxJQUFJLHFEQUFxRCxJQUFJLHdCQUF3QixJQUFJO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsS0FBSyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSx1REFBdUQ7QUFDdkQscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxnQkFBZ0IsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjLCtCQUErQjtBQUM3QyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHlCQUF5QjtBQUN2QyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLHdCQUF3QjtBQUN0QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQ0FBMkM7QUFDaEUsY0FBYztBQUNkO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDO0FBQ2hFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBeUQ7QUFDL0Usc0JBQXNCLHlEQUF5RDtBQUMvRSxvQkFBb0Isd0RBQXdEO0FBQzVFLG9CQUFvQix3REFBd0Q7QUFDNUU7QUFDQTtBQUNBLHNCQUFzQix5Q0FBeUM7QUFDL0QsY0FBYztBQUNkO0FBQ0E7QUFDQSxzQkFBc0IseUNBQXlDO0FBQy9ELGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQix5Q0FBeUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUE4RDtBQUNuRixxQkFBcUIsOERBQThEO0FBQ25GO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9ELGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDO0FBQ3pGLDZDQUE2Qyw4Q0FBOEM7QUFDM0Y7QUFDQTtBQUNBLDJCQUEyQixLQUFLLGtEQUFrRCxFQUFFLEdBQUc7QUFDdkYsZ0NBQWdDLHVEQUF1RDtBQUN2RixnQ0FBZ0MsdURBQXVEO0FBQ3ZGLGdDQUFnQyx1REFBdUQ7QUFDdkY7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQXlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQXlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5Q0FBeUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5Q0FBeUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQW9EO0FBQzFFLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QyxjQUFjLHdCQUF3QjtBQUN0QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekMsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekMsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSyxrRUFBa0U7QUFDdkY7QUFDQTtBQUNBLGVBQWUsS0FBSyxnREFBZ0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VkaXRvci8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNpYy1sYW5ndWFnZXMvZWxpeGlyL2VsaXhpci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IHZhciBjb25mID0ge1xyXG4gICAgY29tbWVudHM6IHtcclxuICAgICAgICBsaW5lQ29tbWVudDogJyMnXHJcbiAgICB9LFxyXG4gICAgYnJhY2tldHM6IFtcclxuICAgICAgICBbJ3snLCAnfSddLFxyXG4gICAgICAgIFsnWycsICddJ10sXHJcbiAgICAgICAgWycoJywgJyknXVxyXG4gICAgXSxcclxuICAgIHN1cnJvdW5kaW5nUGFpcnM6IFtcclxuICAgICAgICB7IG9wZW46ICd7JywgY2xvc2U6ICd9JyB9LFxyXG4gICAgICAgIHsgb3BlbjogJ1snLCBjbG9zZTogJ10nIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnKCcsIGNsb3NlOiAnKScgfSxcclxuICAgICAgICB7IG9wZW46IFwiJ1wiLCBjbG9zZTogXCInXCIgfSxcclxuICAgICAgICB7IG9wZW46ICdcIicsIGNsb3NlOiAnXCInIH1cclxuICAgIF0sXHJcbiAgICBhdXRvQ2xvc2luZ1BhaXJzOiBbXHJcbiAgICAgICAgeyBvcGVuOiBcIidcIiwgY2xvc2U6IFwiJ1wiLCBub3RJbjogWydzdHJpbmcnLCAnY29tbWVudCddIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnXCInLCBjbG9zZTogJ1wiJywgbm90SW46IFsnY29tbWVudCddIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnXCJcIlwiJywgY2xvc2U6ICdcIlwiXCInIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnYCcsIGNsb3NlOiAnYCcsIG5vdEluOiBbJ3N0cmluZycsICdjb21tZW50J10gfSxcclxuICAgICAgICB7IG9wZW46ICcoJywgY2xvc2U6ICcpJyB9LFxyXG4gICAgICAgIHsgb3BlbjogJ3snLCBjbG9zZTogJ30nIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnWycsIGNsb3NlOiAnXScgfSxcclxuICAgICAgICB7IG9wZW46ICc8PCcsIGNsb3NlOiAnPj4nIH1cclxuICAgIF0sXHJcbiAgICBpbmRlbnRhdGlvblJ1bGVzOiB7XHJcbiAgICAgICAgaW5jcmVhc2VJbmRlbnRQYXR0ZXJuOiAvXlxccyooYWZ0ZXJ8ZWxzZXxjYXRjaHxyZXNjdWV8Zm58W14jXSooZG98PFxcLXxcXC0+fFxce3xcXFt8XFw9KSlcXHMqJC8sXHJcbiAgICAgICAgZGVjcmVhc2VJbmRlbnRQYXR0ZXJuOiAvXlxccyooKFxcfXxcXF0pXFxzKiR8KGFmdGVyfGVsc2V8Y2F0Y2h8cmVzY3VlfGVuZClcXGIpL1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQSBNb25hcmNoIGxleGVyIGZvciB0aGUgRWxpeGlyIGxhbmd1YWdlLlxyXG4gKlxyXG4gKiBSZWZlcmVuY2VzOlxyXG4gKlxyXG4gKiAqIE1vbmFyY2ggZG9jdW1lbnRhdGlvbiAtIGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9tb25hY28tZWRpdG9yL21vbmFyY2guaHRtbFxyXG4gKiAqIEVsaXhpciBsZXhlciAtIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGl4aXItbWFrZXVwL21ha2V1cF9lbGl4aXIvYmxvYi9tYXN0ZXIvbGliL21ha2V1cC9sZXhlcnMvZWxpeGlyX2xleGVyLmV4XHJcbiAqICogVGV4dE1hdGUgbGV4ZXIgKGVsaXhpci10bWJ1bmRsZSkgLSBodHRwczovL2dpdGh1Yi5jb20vZWxpeGlyLWVkaXRvcnMvZWxpeGlyLXRtYnVuZGxlL2Jsb2IvbWFzdGVyL1N5bnRheGVzL0VsaXhpci50bUxhbmd1YWdlXHJcbiAqICogVGV4dE1hdGUgbGV4ZXIgKHZzY29kZS1lbGl4aXItbHMpIC0gaHR0cHM6Ly9naXRodWIuY29tL2VsaXhpci1sc3AvdnNjb2RlLWVsaXhpci1scy9ibG9iL21hc3Rlci9zeW50YXhlcy9lbGl4aXIuanNvblxyXG4gKi9cclxuZXhwb3J0IHZhciBsYW5ndWFnZSA9IHtcclxuICAgIGRlZmF1bHRUb2tlbjogJ3NvdXJjZScsXHJcbiAgICB0b2tlblBvc3RmaXg6ICcuZWxpeGlyJyxcclxuICAgIGJyYWNrZXRzOiBbXHJcbiAgICAgICAgeyBvcGVuOiAnWycsIGNsb3NlOiAnXScsIHRva2VuOiAnZGVsaW1pdGVyLnNxdWFyZScgfSxcclxuICAgICAgICB7IG9wZW46ICcoJywgY2xvc2U6ICcpJywgdG9rZW46ICdkZWxpbWl0ZXIucGFyZW50aGVzaXMnIH0sXHJcbiAgICAgICAgeyBvcGVuOiAneycsIGNsb3NlOiAnfScsIHRva2VuOiAnZGVsaW1pdGVyLmN1cmx5JyB9LFxyXG4gICAgICAgIHsgb3BlbjogJzw8JywgY2xvc2U6ICc+PicsIHRva2VuOiAnZGVsaW1pdGVyLmFuZ2xlLnNwZWNpYWwnIH1cclxuICAgIF0sXHJcbiAgICAvLyBCZWxvdyBhcmUgbGlzdHMvcmVnZXhwcyB0byB3aGljaCB3ZSByZWZlcmVuY2UgbGF0ZXIuXHJcbiAgICBkZWNsYXJhdGlvbktleXdvcmRzOiBbXHJcbiAgICAgICAgJ2RlZicsXHJcbiAgICAgICAgJ2RlZnAnLFxyXG4gICAgICAgICdkZWZuJyxcclxuICAgICAgICAnZGVmbnAnLFxyXG4gICAgICAgICdkZWZndWFyZCcsXHJcbiAgICAgICAgJ2RlZmd1YXJkcCcsXHJcbiAgICAgICAgJ2RlZm1hY3JvJyxcclxuICAgICAgICAnZGVmbWFjcm9wJyxcclxuICAgICAgICAnZGVmZGVsZWdhdGUnLFxyXG4gICAgICAgICdkZWZjYWxsYmFjaycsXHJcbiAgICAgICAgJ2RlZm1hY3JvY2FsbGJhY2snLFxyXG4gICAgICAgICdkZWZtb2R1bGUnLFxyXG4gICAgICAgICdkZWZwcm90b2NvbCcsXHJcbiAgICAgICAgJ2RlZmV4Y2VwdGlvbicsXHJcbiAgICAgICAgJ2RlZmltcGwnLFxyXG4gICAgICAgICdkZWZzdHJ1Y3QnXHJcbiAgICBdLFxyXG4gICAgb3BlcmF0b3JLZXl3b3JkczogWydhbmQnLCAnaW4nLCAnbm90JywgJ29yJywgJ3doZW4nXSxcclxuICAgIG5hbWVzcGFjZUtleXdvcmRzOiBbJ2FsaWFzJywgJ2ltcG9ydCcsICdyZXF1aXJlJywgJ3VzZSddLFxyXG4gICAgb3RoZXJLZXl3b3JkczogW1xyXG4gICAgICAgICdhZnRlcicsXHJcbiAgICAgICAgJ2Nhc2UnLFxyXG4gICAgICAgICdjYXRjaCcsXHJcbiAgICAgICAgJ2NvbmQnLFxyXG4gICAgICAgICdkbycsXHJcbiAgICAgICAgJ2Vsc2UnLFxyXG4gICAgICAgICdlbmQnLFxyXG4gICAgICAgICdmbicsXHJcbiAgICAgICAgJ2ZvcicsXHJcbiAgICAgICAgJ2lmJyxcclxuICAgICAgICAncXVvdGUnLFxyXG4gICAgICAgICdyYWlzZScsXHJcbiAgICAgICAgJ3JlY2VpdmUnLFxyXG4gICAgICAgICdyZXNjdWUnLFxyXG4gICAgICAgICdzdXBlcicsXHJcbiAgICAgICAgJ3Rocm93JyxcclxuICAgICAgICAndHJ5JyxcclxuICAgICAgICAndW5sZXNzJyxcclxuICAgICAgICAndW5xdW90ZV9zcGxpY2luZycsXHJcbiAgICAgICAgJ3VucXVvdGUnLFxyXG4gICAgICAgICd3aXRoJ1xyXG4gICAgXSxcclxuICAgIGNvbnN0YW50czogWyd0cnVlJywgJ2ZhbHNlJywgJ25pbCddLFxyXG4gICAgbmFtZUJ1aWx0aW46IFsnX19NT0RVTEVfXycsICdfX0RJUl9fJywgJ19fRU5WX18nLCAnX19DQUxMRVJfXycsICdfX1NUQUNLVFJBQ0VfXyddLFxyXG4gICAgLy8gTWF0Y2hlcyBhbnkgb2YgdGhlIG9wZXJhdG9yIG5hbWVzOlxyXG4gICAgLy8gPDw8ID4+PiB8fHwgJiYmIF5eXiB+fn4gPT09ICE9PSB+Pj4gPH4+IHx+PiA8fD4gPT0gIT0gPD0gPj0gJiYgfHwgXFxcXCA8PiArKyAtLSB8PiA9fiAtPiA8LSB+PiA8fiA6OiAuLiA9IDwgPiArIC0gKiAvIHwgLiBeICYgIVxyXG4gICAgb3BlcmF0b3I6IC8tWy0+XT98IT17MCwyfXxcXCp8XFwvfFxcXFxcXFxcfCZ7MSwzfXxcXC5cXC4/fFxcXig/OlxcXlxcXik/fFxcK1xcKz98PCg/Oi18PDx8PXw+fFxcfD58fj4/KT98PX58PXsxLDN9fD4oPzo9fD4+KT98XFx8fj58XFx8PnxcXHx7MSwzfXx+Pj4/fH5+fnw6Oi8sXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9oZXhkb2NzLnBtL2VsaXhpci9zeW50YXgtcmVmZXJlbmNlLmh0bWwjdmFyaWFibGVzXHJcbiAgICB2YXJpYWJsZU5hbWU6IC9bYS16X11bYS16QS1aMC05X10qWz8hXT8vLFxyXG4gICAgLy8gU2VlIGh0dHBzOi8vaGV4ZG9jcy5wbS9lbGl4aXIvc3ludGF4LXJlZmVyZW5jZS5odG1sI2F0b21zXHJcbiAgICBhdG9tTmFtZTogL1thLXpBLVpfXVthLXpBLVowLTlfQF0qWz8hXT98QHNwZWNpYWxBdG9tTmFtZXxAb3BlcmF0b3IvLFxyXG4gICAgc3BlY2lhbEF0b21OYW1lOiAvXFwuXFwuXFwufDw8Pj58JVxce1xcfXwlfFxce1xcfS8sXHJcbiAgICBhbGlhc1BhcnQ6IC9bQS1aXVthLXpBLVowLTlfXSovLFxyXG4gICAgbW9kdWxlTmFtZTogL0BhbGlhc1BhcnQoPzpcXC5AYWxpYXNQYXJ0KSovLFxyXG4gICAgLy8gU2lnaWwgcGFpcnMgYXJlOiBcIlwiXCIgXCJcIlwiLCAnJycgJycnLCBcIiBcIiwgJyAnLCAvIC8sIHwgfCwgPCA+LCB7IH0sIFsgXSwgKCApXHJcbiAgICBzaWdpbFN5bW1ldHJpY0RlbGltaXRlcjogL1wiXCJcInwnJyd8XCJ8J3xcXC98XFx8LyxcclxuICAgIHNpZ2lsU3RhcnREZWxpbWl0ZXI6IC9Ac2lnaWxTeW1tZXRyaWNEZWxpbWl0ZXJ8PHxcXHt8XFxbfFxcKC8sXHJcbiAgICBzaWdpbEVuZERlbGltaXRlcjogL0BzaWdpbFN5bW1ldHJpY0RlbGltaXRlcnw+fFxcfXxcXF18XFwpLyxcclxuICAgIGRlY2ltYWw6IC9cXGQoPzpfP1xcZCkqLyxcclxuICAgIGhleDogL1swLTlhLWZBLUZdKF8/WzAtOWEtZkEtRl0pKi8sXHJcbiAgICBvY3RhbDogL1swLTddKF8/WzAtN10pKi8sXHJcbiAgICBiaW5hcnk6IC9bMDFdKF8/WzAxXSkqLyxcclxuICAgIC8vIFNlZSBodHRwczovL2hleGRvY3MucG0vZWxpeGlyL21hc3Rlci9TdHJpbmcuaHRtbCNtb2R1bGUtZXNjYXBlLWNoYXJhY3RlcnNcclxuICAgIGVzY2FwZTogL1xcXFx1WzAtOWEtZkEtRl17NH18XFxcXHhbMC05YS1mQS1GXXsyfXxcXFxcLi8sXHJcbiAgICAvLyBUaGUga2V5cyBiZWxvdyBjb3JyZXNwb25kIHRvIHRva2VuaXplciBzdGF0ZXMuXHJcbiAgICAvLyBXZSBzdGFydCBmcm9tIHRoZSByb290IHN0YXRlIGFuZCBtYXRjaCBhZ2FpbnN0IGl0cyBydWxlc1xyXG4gICAgLy8gdW50aWwgd2UgZXhwbGljaXRseSB0cmFuc2l0aW9uIGludG8gYW5vdGhlciBzdGF0ZS5cclxuICAgIC8vIFRoZSBgaW5jbHVkZWAgc2ltcGx5IGJyaW5ncyBpbiBhbGwgb3BlcmF0aW9ucyBmcm9tIHRoZSBnaXZlbiBzdGF0ZVxyXG4gICAgLy8gYW5kIGlzIHVzZWZ1bCBmb3IgaW1wcm92aW5nIHJlYWRhYmlsaXR5LlxyXG4gICAgdG9rZW5pemVyOiB7XHJcbiAgICAgICAgcm9vdDogW1xyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAd2hpdGVzcGFjZScgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGNvbW1lbnRzJyB9LFxyXG4gICAgICAgICAgICAvLyBLZXl3b3JkcyBzdGFydCBhcyBlaXRoZXIgYW4gaWRlbnRpZmllciBvciBhIHN0cmluZyxcclxuICAgICAgICAgICAgLy8gYnV0IGVuZCB3aXRoIGEgOiBzbyBpdCdzIGltcG9ydGFudCB0byBtYXRjaCB0aGlzIGZpcnN0LlxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAa2V5d29yZHNTaG9ydGhhbmQnIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BudW1iZXJzJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAaWRlbnRpZmllcnMnIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdzJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAYXRvbXMnIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzaWdpbHMnIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BhdHRyaWJ1dGVzJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3ltYm9scycgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gV2hpdGVzcGFjZVxyXG4gICAgICAgIHdoaXRlc3BhY2U6IFtbL1xccysvLCAnd2hpdGUnXV0sXHJcbiAgICAgICAgLy8gQ29tbWVudHNcclxuICAgICAgICBjb21tZW50czogW1svKCMpKC4qKS8sIFsnY29tbWVudC5wdW5jdHVhdGlvbicsICdjb21tZW50J11dXSxcclxuICAgICAgICAvLyBLZXl3b3JkIGxpc3Qgc2hvcnRoYW5kXHJcbiAgICAgICAga2V5d29yZHNTaG9ydGhhbmQ6IFtcclxuICAgICAgICAgICAgWy8oQGF0b21OYW1lKSg6KS8sIFsnY29uc3RhbnQnLCAnY29uc3RhbnQucHVuY3R1YXRpb24nXV0sXHJcbiAgICAgICAgICAgIC8vIFVzZSBwb3NpdGl2ZSBsb29rLWFoZWFkIHRvIGVuc3VyZSB0aGUgc3RyaW5nIGlzIGZvbGxvd2VkIGJ5IDpcclxuICAgICAgICAgICAgLy8gYW5kIHNob3VsZCBiZSBjb25zaWRlcmVkIGEga2V5d29yZC5cclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL1wiKD89KFteXCJdfCNcXHsuKj9cXH18XFxcXFwiKSpcIjopLyxcclxuICAgICAgICAgICAgICAgIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQGRvdWJsZVF1b3RlZFN0cmluZ0tleXdvcmQnIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLycoPz0oW14nXXwjXFx7Lio/XFx9fFxcXFwnKSonOikvLFxyXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAc2luZ2xlUXVvdGVkU3RyaW5nS2V5d29yZCcgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb3VibGVRdW90ZWRTdHJpbmdLZXl3b3JkOiBbXHJcbiAgICAgICAgICAgIFsvXCI6LywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBzaW5nbGVRdW90ZWRTdHJpbmdLZXl3b3JkOiBbXHJcbiAgICAgICAgICAgIFsvJzovLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIE51bWJlcnNcclxuICAgICAgICBudW1iZXJzOiBbXHJcbiAgICAgICAgICAgIFsvMGJAYmluYXJ5LywgJ251bWJlci5iaW5hcnknXSxcclxuICAgICAgICAgICAgWy8wb0BvY3RhbC8sICdudW1iZXIub2N0YWwnXSxcclxuICAgICAgICAgICAgWy8weEBoZXgvLCAnbnVtYmVyLmhleCddLFxyXG4gICAgICAgICAgICBbL0BkZWNpbWFsXFwuQGRlY2ltYWwoW2VFXS0/QGRlY2ltYWwpPy8sICdudW1iZXIuZmxvYXQnXSxcclxuICAgICAgICAgICAgWy9AZGVjaW1hbC8sICdudW1iZXInXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gSWRlbnRpZmllcnNcclxuICAgICAgICBpZGVudGlmaWVyczogW1xyXG4gICAgICAgICAgICAvLyBUb2tlbml6ZSBpZGVudGlmaWVyIG5hbWUgaW4gZnVuY3Rpb24tbGlrZSBkZWZpbml0aW9ucy5cclxuICAgICAgICAgICAgLy8gTm90ZTogZ2l2ZW4gYGRlZiBhICsgYiwgZG86IG5pbGAsIGBhYCBpcyBub3QgYSBmdW5jdGlvbiBuYW1lLFxyXG4gICAgICAgICAgICAvLyBzbyB3ZSB1c2UgbmVnYXRpdmUgbG9vay1haGVhZCB0byBlbnN1cmUgdGhlcmUncyBubyBvcGVyYXRvci5cclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL1xcYihkZWZwP3xkZWZucD98ZGVmbWFjcm9wP3xkZWZndWFyZHA/fGRlZmRlbGVnYXRlKShcXHMrKShAdmFyaWFibGVOYW1lKSg/IVxccytAb3BlcmF0b3IpLyxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAna2V5d29yZC5kZWNsYXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnF1b3RlOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8vIFRva2VuaXplIGZ1bmN0aW9uIGNhbGxzXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8vIEluLXNjb3BlIGNhbGwgLSBhbiBpZGVudGlmaWVyIGZvbGxvd2VkIGJ5ICggb3IgLihcclxuICAgICAgICAgICAgICAgIC8oQHZhcmlhYmxlTmFtZSkoPz1cXHMqXFwuP1xccypcXCgpLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2tlbml6ZSBhcyBrZXl3b3JkIGluIGNhc2VzIGxpa2UgYGlmKC4uLiwgZG86IC4uLiwgZWxzZTogLi4uKWBcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWNsYXJhdGlvbktleXdvcmRzJzogJ2tleXdvcmQuZGVjbGFyYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG5hbWVzcGFjZUtleXdvcmRzJzogJ2tleXdvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG90aGVyS2V5d29yZHMnOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdmdW5jdGlvbi5jYWxsJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNpbmcgZnVuY3Rpb24gaW4gYSBtb2R1bGVcclxuICAgICAgICAgICAgICAgIC8oQG1vZHVsZU5hbWUpKFxccyopKFxcLikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxyXG4gICAgICAgICAgICAgICAgWyd0eXBlLmlkZW50aWZpZXInLCAnd2hpdGUnLCAnb3BlcmF0b3InLCAnd2hpdGUnLCAnZnVuY3Rpb24uY2FsbCddXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jaW5nIGZ1bmN0aW9uIGluIGFuIEVybGFuZyBtb2R1bGVcclxuICAgICAgICAgICAgICAgIC8oOikoQGF0b21OYW1lKShcXHMqKShcXC4pKFxccyopKEB2YXJpYWJsZU5hbWUpLyxcclxuICAgICAgICAgICAgICAgIFsnY29uc3RhbnQucHVuY3R1YXRpb24nLCAnY29uc3RhbnQnLCAnd2hpdGUnLCAnb3BlcmF0b3InLCAnd2hpdGUnLCAnZnVuY3Rpb24uY2FsbCddXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8vIFBpcGluZyBpbnRvIGEgZnVuY3Rpb24gKHRva2VuaXplZCBzZXBhcmF0ZWx5IGFzIGl0IG1heSBub3QgaGF2ZSBwYXJlbnRoZXNlcylcclxuICAgICAgICAgICAgICAgIC8oXFx8PikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgICdvcGVyYXRvcicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQG90aGVyS2V5d29yZHMnOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnZnVuY3Rpb24uY2FsbCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gcmVmZXJlbmNlIHBhc3NlZCB0byBhbm90aGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAvKCYpKFxccyopKEB2YXJpYWJsZU5hbWUpLyxcclxuICAgICAgICAgICAgICAgIFsnb3BlcmF0b3InLCAnd2hpdGUnLCAnZnVuY3Rpb24uY2FsbCddXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8vIExhbmd1YWdlIGtleXdvcmRzLCBidWlsdGlucywgY29uc3RhbnRzIGFuZCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL0B2YXJpYWJsZU5hbWUvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVjbGFyYXRpb25LZXl3b3Jkcyc6ICdrZXl3b3JkLmRlY2xhcmF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BvcGVyYXRvcktleXdvcmRzJzogJ2tleXdvcmQub3BlcmF0b3InLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG5hbWVzcGFjZUtleXdvcmRzJzogJ2tleXdvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG90aGVyS2V5d29yZHMnOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAY29uc3RhbnRzJzogJ2NvbnN0YW50Lmxhbmd1YWdlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BuYW1lQnVpbHRpbic6ICd2YXJpYWJsZS5sYW5ndWFnZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdfLionOiAnY29tbWVudC51bnVzZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnaWRlbnRpZmllcidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8vIE1vZHVsZSBuYW1lc1xyXG4gICAgICAgICAgICBbL0Btb2R1bGVOYW1lLywgJ3R5cGUuaWRlbnRpZmllciddXHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBTdHJpbmdzXHJcbiAgICAgICAgc3RyaW5nczogW1xyXG4gICAgICAgICAgICBbL1wiXCJcIi8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bkb3VibGVRdW90ZWRIZXJlZG9jJyB9XSxcclxuICAgICAgICAgICAgWy8nJycvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAc2luZ2xlUXVvdGVkSGVyZWRvYycgfV0sXHJcbiAgICAgICAgICAgIFsvXCIvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAZG91YmxlUXVvdGVkU3RyaW5nJyB9XSxcclxuICAgICAgICAgICAgWy8nLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHNpbmdsZVF1b3RlZFN0cmluZycgfV1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvdWJsZVF1b3RlZEhlcmVkb2M6IFtcclxuICAgICAgICAgICAgWy9cIlwiXCIvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnRJbnRlcnBvbCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc2luZ2xlUXVvdGVkSGVyZWRvYzogW1xyXG4gICAgICAgICAgICBbLycnJy8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudEludGVycG9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb3VibGVRdW90ZWRTdHJpbmc6IFtcclxuICAgICAgICAgICAgWy9cIi8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudEludGVycG9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBzaW5nbGVRdW90ZWRTdHJpbmc6IFtcclxuICAgICAgICAgICAgWy8nLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIEF0b21zXHJcbiAgICAgICAgYXRvbXM6IFtcclxuICAgICAgICAgICAgWy8oOikoQGF0b21OYW1lKS8sIFsnY29uc3RhbnQucHVuY3R1YXRpb24nLCAnY29uc3RhbnQnXV0sXHJcbiAgICAgICAgICAgIFsvOlwiLywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAZG91YmxlUXVvdGVkU3RyaW5nQXRvbScgfV0sXHJcbiAgICAgICAgICAgIFsvOicvLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0BzaW5nbGVRdW90ZWRTdHJpbmdBdG9tJyB9XVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG91YmxlUXVvdGVkU3RyaW5nQXRvbTogW1xyXG4gICAgICAgICAgICBbL1wiLywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBzaW5nbGVRdW90ZWRTdHJpbmdBdG9tOiBbXHJcbiAgICAgICAgICAgIFsvJy8sIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb25zdGFudENvbnRlbnRJbnRlcnBvbCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gU2lnaWxzXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZWxpeGlyLWxhbmcub3JnL2dldHRpbmctc3RhcnRlZC9zaWdpbHMuaHRtbFxyXG4gICAgICAgIC8vIFNpZ2lscyBhbGxvdyBmb3IgdHlwaW5nIHZhbHVlcyB1c2luZyB0aGVpciB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICAgIC8vIEFsbCBzaWdpbHMgc3RhcnQgd2l0aCB+IGZvbGxvd2VkIGJ5IGEgbGV0dGVyIGluZGljYXRpbmcgc2lnaWwgdHlwZVxyXG4gICAgICAgIC8vIGFuZCB0aGVuIGEgZGVsaW1pdGVyIHBhaXIgZW5jbG9zaW5nIHRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICAgIC8vIE9wdGlvbmFsIG1vZGlmaWVycyBhcmUgYWxsb3dlZCBhZnRlciB0aGUgY2xvc2luZyBkZWxpbWl0ZXIuXHJcbiAgICAgICAgLy8gRm9yIGluc3RhbmNlIGEgcmVndWxhciBleHByZXNzaW9ucyBjYW4gYmUgd3JpdHRlbiBhczpcclxuICAgICAgICAvLyB+ci9mb298YmFyLyB+cntmb298YmFyfSB+ci9mb298YmFyL2dcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEluIGdlbmVyYWwgbG93ZXJjYXNlIHNpZ2lscyBhbGxvdyBmb3IgaW50ZXJwb2xhdGlvblxyXG4gICAgICAgIC8vIGFuZCBlc2NhcGVkIGNoYXJhY3RlcnMsIHdoZXJlYXMgdXBwZXJjYXNlIHNpZ2lscyBkb24ndFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gRHVyaW5nIHRva2VuaXphdGlvbiB3ZSB3YW50IHRvIGRpc3Rpbmd1aXNoIHNvbWVcclxuICAgICAgICAvLyBzcGVjaWZpYyBzaWdpbCB0eXBlcywgbmFtZWx5IHN0cmluZyBhbmQgcmVnZXhwLFxyXG4gICAgICAgIC8vIHNvIHRoYXQgdGhleSBjZW4gYmUgdGhlbWVkIHNlcGFyYXRlbHkuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUbyByZWFzb25hYmx5IGhhbmRsZSBhbGwgdGhvc2UgY29tYmluYXRpb25zIHdlIGxldmVyYWdlXHJcbiAgICAgICAgLy8gZG90LXNlcGFyYXRlZCBzdGF0ZXMsIHNvIGlmIHdlIHRyYW5zaXRpb24gdG8gQHNpZ2lsU3RhcnQuaW50ZXJwb2wucy57Ln1cclxuICAgICAgICAvLyB0aGVuIFwic2lnaWxTdGFydC5pbnRlcnBvbC5zXCIgc3RhdGUgd2lsbCBtYXRjaCBhbmQgYWxzbyBhbGxcclxuICAgICAgICAvLyB0aGUgaW5kaXZpZHVhbCBkb3Qtc2VwYXJhdGVkIHBhcmFtZXRlcnMgY2FuIGJlIGFjY2Vzc2VkLlxyXG4gICAgICAgIHNpZ2lsczogW1xyXG4gICAgICAgICAgICBbL35bYS16XUBzaWdpbFN0YXJ0RGVsaW1pdGVyLywgeyB0b2tlbjogJ0ByZW1hdGNoJywgbmV4dDogJ0BzaWdpbC5pbnRlcnBvbCcgfV0sXHJcbiAgICAgICAgICAgIFsvfltBLVpdQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBuZXh0OiAnQHNpZ2lsLm5vSW50ZXJwb2wnIH1dXHJcbiAgICAgICAgXSxcclxuICAgICAgICBzaWdpbDogW1xyXG4gICAgICAgICAgICBbL34oW2EtekEtWl0pXFx7LywgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuey59JyB9XSxcclxuICAgICAgICAgICAgWy9+KFthLXpBLVpdKVxcWy8sIHsgdG9rZW46ICdAcmVtYXRjaCcsIHN3aXRjaFRvOiAnQHNpZ2lsU3RhcnQuJFMyLiQxLlsuXScgfV0sXHJcbiAgICAgICAgICAgIFsvfihbYS16QS1aXSlcXCgvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS4oLiknIH1dLFxyXG4gICAgICAgICAgICBbL34oW2EtekEtWl0pXFw8LywgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuPC4+JyB9XSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL34oW2EtekEtWl0pKEBzaWdpbFN5bW1ldHJpY0RlbGltaXRlcikvLFxyXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuJDIuJDInIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gVGhlIGRlZmluaXRpb25zIGJlbG93IGV4cGVjdCBzdGF0ZXMgdG8gYmUgb2YgdGhlIGZvcm06XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBzaWdpbFN0YXJ0LjxpbnRlcnBvbC1vci1ub0ludGVycG9sPi48c2lnaWwtbGV0dGVyPi48c3RhcnQtZGVsaW1pdGVyPi48ZW5kLWRlbGltaXRlcj5cclxuICAgICAgICAvLyBzaWdpbENvbnRpbnVlLjxpbnRlcnBvbC1vci1ub0ludGVycG9sPi48c2lnaWwtbGV0dGVyPi48c3RhcnQtZGVsaW1pdGVyPi48ZW5kLWRlbGltaXRlcj5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoZSBzaWdpbFN0YXJ0IHN0YXRlIGlzIHVzZWQgb25seSB0byBwcm9wZXJseSBjbGFzc2lmeSB0aGUgdG9rZW4gKGFzIHN0cmluZy9yZWdleC9zaWdpbClcclxuICAgICAgICAvLyBhbmQgaW1tZWRpYXRlbHkgc3dpdGNoZXMgdG8gdGhlIHNpZ2lsQ29udGludWUgc2F0ZSwgd2hpY2ggaGFuZGxlcyB0aGUgYWN0dWFsIGNvbnRlbnRcclxuICAgICAgICAvLyBhbmQgd2FpdHMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGVuZCBkZWxpbWl0ZXIuXHJcbiAgICAgICAgJ3NpZ2lsU3RhcnQuaW50ZXJwb2wucyc6IFtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL35zQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbENvbnRpbnVlLmludGVycG9sLnMnOiBbXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnRJbnRlcnBvbCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsU3RhcnQubm9JbnRlcnBvbC5TJzogW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvflNAc2lnaWxTdGFydERlbGltaXRlci8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsQ29udGludWUubm9JbnRlcnBvbC5TJzogW1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXNjYXBlZCBzaWdpbCBlbmRcclxuICAgICAgICAgICAgWy8oXnxbXlxcXFxdKVxcXFxAc2lnaWxFbmREZWxpbWl0ZXIvLCAnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnQnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbFN0YXJ0LmludGVycG9sLnInOiBbXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9+ckBzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ3JlZ2V4cC5kZWxpbWl0ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvOiAnQHNpZ2lsQ29udGludWUuJFMyLiRTMy4kUzQuJFM1J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXSxcclxuICAgICAgICAnc2lnaWxDb250aW51ZS5pbnRlcnBvbC5yJzogW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilbYS16QS1aXSovLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICckMT09JFM1JzogeyB0b2tlbjogJ3JlZ2V4cC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ3JlZ2V4cCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0ByZWdleHBDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbFN0YXJ0Lm5vSW50ZXJwb2wuUic6IFtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL35SQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAncmVnZXhwLmRlbGltaXRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbENvbnRpbnVlLm5vSW50ZXJwb2wuUic6IFtcclxuICAgICAgICAgICAgLy8gSWdub3JlIGVzY2FwZWQgc2lnaWwgZW5kXHJcbiAgICAgICAgICAgIFsvKF58W15cXFxcXSlcXFxcQHNpZ2lsRW5kRGVsaW1pdGVyLywgJ3JlZ2V4cCddLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilbYS16QS1aXSovLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICckMT09JFM1JzogeyB0b2tlbjogJ3JlZ2V4cC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ3JlZ2V4cCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0ByZWdleHBDb250ZW50JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBGYWxsYmFjayB0byB0aGUgZ2VuZXJpYyBzaWdpbCBieSBkZWZhdWx0XHJcbiAgICAgICAgJ3NpZ2lsU3RhcnQuaW50ZXJwb2wnOiBbXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9+KFthLXpBLVpdKUBzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ3NpZ2lsLmRlbGltaXRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbENvbnRpbnVlLmludGVycG9sJzogW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilbYS16QS1aXSovLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICckMT09JFM1JzogeyB0b2tlbjogJ3NpZ2lsLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc2lnaWwnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc2lnaWxDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbFN0YXJ0Lm5vSW50ZXJwb2wnOiBbXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9+KFthLXpBLVpdKUBzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ3NpZ2lsLmRlbGltaXRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbENvbnRpbnVlLm5vSW50ZXJwb2wnOiBbXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBlc2NhcGVkIHNpZ2lsIGVuZFxyXG4gICAgICAgICAgICBbLyhefFteXFxcXF0pXFxcXEBzaWdpbEVuZERlbGltaXRlci8sICdzaWdpbCddLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvKEBzaWdpbEVuZERlbGltaXRlcilbYS16QS1aXSovLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICckMT09JFM1JzogeyB0b2tlbjogJ3NpZ2lsLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc2lnaWwnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc2lnaWxDb250ZW50JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBBdHRyaWJ1dGVzXHJcbiAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAvLyBNb2R1bGUgQGRvYyogYXR0cmlidXRlcyAtIHRva2VuaXplZCBhcyBjb21tZW50c1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvXFxAKG1vZHVsZXx0eXBlKT9kb2MgKH5bc1NdKT9cIlwiXCIvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiAnQGRvdWJsZVF1b3RlZEhlcmVkb2NEb2NzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9cXEAobW9kdWxlfHR5cGUpP2RvYyAofltzU10pP1wiLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ2NvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogJ0Bkb3VibGVRdW90ZWRTdHJpbmdEb2NzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsvXFxAKG1vZHVsZXx0eXBlKT9kb2MgZmFsc2UvLCAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJ10sXHJcbiAgICAgICAgICAgIC8vIE1vZHVsZSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIFsvXFxAKEB2YXJpYWJsZU5hbWUpLywgJ3ZhcmlhYmxlJ11cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvdWJsZVF1b3RlZEhlcmVkb2NEb2NzdHJpbmc6IFtcclxuICAgICAgICAgICAgWy9cIlwiXCIvLCB7IHRva2VuOiAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZG9jc3RyaW5nQ29udGVudCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG91YmxlUXVvdGVkU3RyaW5nRG9jc3RyaW5nOiBbXHJcbiAgICAgICAgICAgIFsvXCIvLCB7IHRva2VuOiAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZG9jc3RyaW5nQ29udGVudCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gT3BlcmF0b3JzLCBwdW5jdHVhdGlvbiwgYnJhY2tldHNcclxuICAgICAgICBzeW1ib2xzOiBbXHJcbiAgICAgICAgICAgIC8vIENvZGUgcG9pbnQgb3BlcmF0b3IgKGVpdGhlciB3aXRoIHJlZ3VsYXIgY2hhcmFjdGVyID9hIG9yIGFuIGVzY2FwZWQgb25lID9cXG4pXHJcbiAgICAgICAgICAgIFsvXFw/KFxcXFwufFteXFxcXFxcc10pLywgJ251bWJlci5jb25zdGFudCddLFxyXG4gICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24gYXJndW1lbnRzXHJcbiAgICAgICAgICAgIFsvJlxcZCsvLCAnb3BlcmF0b3InXSxcclxuICAgICAgICAgICAgLy8gQml0c2hpZnQgb3BlcmF0b3JzIChtdXN0IGdvIGJlZm9yZSBkZWxpbWl0ZXJzLCBzbyB0aGF0IDw8ID4+IGRvbid0IG1hdGNoIGZpcnN0KVxyXG4gICAgICAgICAgICBbLzw8PHw+Pj4vLCAnb3BlcmF0b3InXSxcclxuICAgICAgICAgICAgLy8gRGVsaW1pdGVyIHBhaXJzXHJcbiAgICAgICAgICAgIFsvWygpXFxbXFxdXFx7XFx9XXw8PHw+Pi8sICdAYnJhY2tldHMnXSxcclxuICAgICAgICAgICAgLy8gVHJpcGxlIGRvdCBpcyBhIHZhbGlkIG5hbWUgKG11c3QgZ28gYmVmb3JlIG9wZXJhdG9ycywgc28gdGhhdCAuLiBkb2Vzbid0IG1hdGNoIGluc3RlYWQpXHJcbiAgICAgICAgICAgIFsvXFwuXFwuXFwuLywgJ2lkZW50aWZpZXInXSxcclxuICAgICAgICAgICAgLy8gUHVuY3R1YXRpb24gPT4gKG11c3QgZ28gYmVmb3JlIG9wZXJhdG9ycywgc28gaXQncyBub3QgdG9rZW5pemVkIGFzID0gdGhlbiA+KVxyXG4gICAgICAgICAgICBbLz0+LywgJ3B1bmN0dWF0aW9uJ10sXHJcbiAgICAgICAgICAgIC8vIE9wZXJhdG9yc1xyXG4gICAgICAgICAgICBbL0BvcGVyYXRvci8sICdvcGVyYXRvciddLFxyXG4gICAgICAgICAgICAvLyBQdW5jdHVhdGlvblxyXG4gICAgICAgICAgICBbL1s6OywuJV0vLCAncHVuY3R1YXRpb24nXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gR2VuZXJpYyBoZWxwZXJzXHJcbiAgICAgICAgc3RyaW5nQ29udGVudEludGVycG9sOiBbXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BpbnRlcnBvbGF0aW9uJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnQnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHN0cmluZ0NvbnRlbnQ6IFtbLy4vLCAnc3RyaW5nJ11dLFxyXG4gICAgICAgIHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sOiBbXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BpbnRlcnBvbGF0aW9uJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc3RyaW5nQ29uc3RhbnRDb250ZW50OiBbWy8uLywgJ2NvbnN0YW50J11dLFxyXG4gICAgICAgIHJlZ2V4cENvbnRlbnRJbnRlcnBvbDogW1xyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAaW50ZXJwb2xhdGlvbicgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGVzY2FwZUNoYXInIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0ByZWdleHBDb250ZW50JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICByZWdleHBDb250ZW50OiBbXHJcbiAgICAgICAgICAgIC8vICMgbWF5IGJlIGEgcmVndWxhciByZWdleHAgY2hhciwgc28gd2UgdXNlIGEgaGV1cmlzdGljXHJcbiAgICAgICAgICAgIC8vIGFzc3VtaW5nIGEgIyBzdXJyb3VuZGVkIGJ5IHdoaXRlc3BhY2UgaXMgYWN0dWFsbHkgYSBjb21tZW50LlxyXG4gICAgICAgICAgICBbLyhcXHMpKCMpKFxccy4qKSQvLCBbJ3doaXRlJywgJ2NvbW1lbnQucHVuY3R1YXRpb24nLCAnY29tbWVudCddXSxcclxuICAgICAgICAgICAgWy8uLywgJ3JlZ2V4cCddXHJcbiAgICAgICAgXSxcclxuICAgICAgICBzaWdpbENvbnRlbnRJbnRlcnBvbDogW1xyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAaW50ZXJwb2xhdGlvbicgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGVzY2FwZUNoYXInIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzaWdpbENvbnRlbnQnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHNpZ2lsQ29udGVudDogW1svLi8sICdzaWdpbCddXSxcclxuICAgICAgICBkb2NzdHJpbmdDb250ZW50OiBbWy8uLywgJ2NvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbiddXSxcclxuICAgICAgICBlc2NhcGVDaGFyOiBbWy9AZXNjYXBlLywgJ2NvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUnXV0sXHJcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogW1xyXG4gICAgICAgICAgICBbLyN7LywgeyB0b2tlbjogJ2RlbGltaXRlci5icmFja2V0LmVtYmVkJywgbmV4dDogJ0BpbnRlcnBvbGF0aW9uQ29udGludWUnIH1dXHJcbiAgICAgICAgXSxcclxuICAgICAgICBpbnRlcnBvbGF0aW9uQ29udGludWU6IFtcclxuICAgICAgICAgICAgWy99LywgeyB0b2tlbjogJ2RlbGltaXRlci5icmFja2V0LmVtYmVkJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICAvLyBJbnRlcnBvbGF0aW9uIGJyYWNrZXRzIG1heSBjb250YWluIGFyYml0cmFyeSBjb2RlLFxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBzaW1wbHkgbWF0Y2ggYWdhaW5zdCBhbGwgdGhlIHJvb3QgcnVsZXMsXHJcbiAgICAgICAgICAgIC8vIHVudGlsIHdlIHJlYWNoIGludGVycG9sYXRpb24gZW5kICh0aGUgYWJvdmUgbWF0Y2hlcykuXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Byb290JyB9XHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=